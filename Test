/* Revised 111416.001
To compile use:
g++ -Wall -lpthread -o mowerpigpio mowerpigpio.cpp -lpigpio -lrt -std=c++14

This program is designed to contol a lawn mower.  The goal is to mow the yard with no user feedback.

The current status is that it will read 4 sensors on the mower to monitor contact with objects and stop or turn away from them.
The detail of how the switches are wired are show in the initialization section.

The pi will also take a pictue and save it or email it to a specified address.  I plan to eventually use the save photos to look
for obstructions and identify the mowers location and orientation.  Location will be x,y,z and orientation will track a heading.

I think that the obstructions will be recorded by location, color, and identification (ie rock, house, fence...).  I would like the pi to ask for the identification.

Several actions will be time controlled.
	Check location every 1 minute while mowing.  (record approximate location based on heading and speed)
	Take a photo every 30 minutes.
        Take and email a photo every 2 hours. 
        Mow every 7 days.

Future adds
Battery monitoring and self recharging.
Georeference with sun, moon, stars...
Moving object identification and avoidance.

*/

#include <iostream>
#include <pigpio.h>
#include <ctime>
#include <ratio>
#include <chrono> // For time controls.

using namespace std;
using namespace std::chrono;

// Initialize Control and set to nominal position.
    int mower_on = 0;  //GPIO17
    int move_on = 0;  //GPIO18
    int forward_reverse = 1; //GPIO27
    int direction = 0;// GPIO23 Uses azmuith relative to the orientation of the mower 0 is straight ahead, 90 is right, 270 is left Range is 0 - 360. 
    int safety = 0;
    int left_detect = 0;  //GPIO16
    int right_detect = 0;  //GPIO20
    int front_detect = 0; //GPIO12
    int rear_detect = 0;  //GPIO21
    int azimuth;
    int currentposition = 1500;
    int kbnumber;
    char kbchar;
    steady_clock::time_point time_boot;
    steady_clock::time_point time_current;
    steady_clock::time_point time_last_locate;
    steady_clock::time_point time_last_picture;
    steady_clock::time_point time_last_mowing;

/* Read the keybord so that it can be used as a remote control up down for move left right to turn.  "z" to stop program
 Assumes "a" = 97; "z" = 122; "w" = 119; "s" = 115.*/

int readkey (void)
{
	cin >> kbchar;
	kbnumber = kbchar;
	return (0);
}

// Reads Sensors and Updates Controls
int controlupdate (void)
{
        mower_on = 1;
        move_on = 1;
	forward_reverse = 1;
        // readkey (); // Make these 2 lines a note to switch to only detector control.
        // cout << "Results of Keyboard read " << kbchar << " = ASCII Number " << kbnumber << endl;
        cout << "Set Jumper for GPIO12, 16, 20 , or 21 " << endl;  
        //  *** cin >> kbchar;
        left_detect = gpioRead(16);
        right_detect = gpioRead(20);  
        rear_detect = gpioRead(21);  
        front_detect = gpioRead(12);
	cout << "Front Left Right Rear" << endl;
	cout << front_detect << "     " << left_detect << "    " << right_detect << "     " << rear_detect << endl;
        //  *** cin >> kbchar;
        if(left_detect == 1||kbnumber == 115) {mower_on = 0; direction = (direction + 10);}
        if(right_detect == 1||kbnumber == 97) {mower_on = 0; direction = (direction - 10);}
        if(left_detect == 0 && right_detect == 0) {direction = 0;}
        if(direction > 360) {direction = (direction - 360);}
        if(direction < 0) {direction = (360 + direction);}
        if(front_detect == 1) {mower_on = 0;forward_reverse = 0;direction = (direction + 10);} 
        if(rear_detect == 1) {mower_on = 0;safety = 1;}
        if(mower_on == 1) {gpioWrite (17, 1);}
             else {gpioWrite (17, 0);}
        if(move_on == 1) {gpioWrite (18, 1);}
             else {gpioWrite (18, 0);}
        if(forward_reverse == 1) {gpioWrite (27, 1);}
             else {gpioWrite (27, 0);}
	return 0;
}

// Sets Steering Servo with the variable direction as the input.
// Needs to be upgraded to allow for more granular control.

int steering (int azimuth)
{
    int c;
    cout << "Steering Module " << azimuth << endl;
    if (azimuth == 360) {c = 1500;}
    if (azimuth >= 0 && azimuth <= 90){c = 1500-azimuth*11;}
    if (azimuth >=270 && azimuth <= 359) {c = (360-azimuth)*11+1500;}
    if (azimuth > 90 && azimuth < 270) {c = 1500;direction = 0;}
    return c;
}

int main (void)
{
  time_boot = steady_clock::now();
  gpioInitialise ();
  gpioSetMode (17,PI_OUTPUT); // Mower control - GPIO17
  gpioSetMode (18,PI_OUTPUT); // Drive Motor Power control - GPIO18 ** Currently On - Off may want to use a Variable Drive of sorts for trimming
  gpioSetMode (27,PI_OUTPUT); // Drive Motor Forward/Reverse - GPIO27  
  gpioSetMode (12,PI_INPUT); // Front Detect Pin Number -  Normally Open switch to 3V on GPIO12 
  gpioSetMode (16,PI_INPUT); // Left Detect Pin Number - Normally Open switch to 3V on GPIO16
  gpioSetMode (20,PI_INPUT); // Right Detect Pin Number - Normally Open switch to 3V on GPIO20
  gpioSetMode (21,PI_INPUT); // Rear Detect Pin Number - Normally Open switch to 3V on GPIO21
  gpioSetPullUpDown (12,PI_PUD_DOWN);
  gpioSetPullUpDown (16,PI_PUD_DOWN);
  gpioSetPullUpDown (20,PI_PUD_DOWN);
  gpioSetPullUpDown (21,PI_PUD_DOWN);
  gpioPWM (23,128); //Activate and set steering servo plugged into pin 23 to 0
  gpioServo (23, 1500); 
  time_current = steady_clock::now();
  duration<double> time_span = duration_cast<duration<double>>(time_current - time_boot);
  duration<double> time_picture = duration_cast<duration<double>>(time_current - time_last_picture);
  duration<double> time_mow = duration_cast<duration<double>>(time_current - time_last_mowing);
  duration<double> time_locate = duration_cast<duration<double>>(time_current - time_last_locate);
  while (time_span.count() < 60)
  {
    controlupdate ();
    currentposition = steering (direction);
    // system ("bash ./Picture.sh"); Saves a picture
    cout << "I have been running for " << time_span.count() << " seconds." << endl;
    gpioServo (23, currentposition);
    cout << "Direction : " << direction << endl;
    cout << "Servo Position : " << currentposition << endl;
    cout << "Mower Power : " << mower_on << endl;
    cout << "Move Power : " << move_on << endl;
    cout << "Safety : " << safety << endl;
    cout << "Front Obstruction Detect : " <<  front_detect << endl; 
    cout << "Left Obstruction Detect : " << left_detect << endl;
    cout << "Right Obstruction Detect : " << right_detect << endl;
    cout << "Rear Obstruction Detect : " << rear_detect << endl;
    gpioSleep(PI_TIME_RELATIVE, 0, 200000); // sleep for 0.2 seconds
    time_current = steady_clock::now();
    time_span = duration_cast<duration<double>>(time_current - time_boot);
    time_picture = duration_cast<duration<double>>(time_current - time_last_picture);
    time_mow = duration_cast<duration<double>>(time_current - time_last_mowing);
    time_locate = duration_cast<duration<double>>(time_current - time_last_locate);
  }
  // Needs a reset plan if the safety goes off.
  void gpioTerminate (void);
  return 0 ;
}
