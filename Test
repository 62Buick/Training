//  This uses the Wiringpi software PWM to adjust the servo plugged into GPIO pin 16.

//  8-27-16 There is a error in the steering module for 270-360 azimuth.  8-30/16 Corrected.
#include <iostream>
#include <wiringPi.h>
#include <softPwm.h> // May replace with pigpio in the future.
#include <pigpio.h>

using namespace std;

// Initialize Control and set to nominal position.
    int mower_on = 0;
    int move_on = 0;
    int direction = 0;// Uses azmuith relative to the orientation of the mower 0 is straight ahead, 90 is right, 270 is left Range is 0 - 360. 
    int safety = 0;
    int left_detect = 0;
    int right_detect = 0;
    int front_detect = 0;
    int rear_detect = 0;
    int azimuth;
    int currentposition = 15;   

// Reads Sensors and Updates Controls
int controlupdate (void)
{
        mower_on = 1;
        move_on = 1;
	cout << "Hit Front : (0 or 1) ";
	cin >> front_detect;
	cout << "Hit Left : (0 or 1) ";
	cin >> left_detect;
	cout << "Hit Right : (0 or 1) ";
	cin >> right_detect;
// Temp test set rear to 1 to exit, it will set safety to 1 which will end the while loop in main.
	cout << "Hit Rear : (0 or 1) ";
	cin >> rear_detect;
        if(left_detect == 1) {mower_on = 0; direction = (direction + 9);}
        if(right_detect == 1) {mower_on = 0; direction = (direction - 9);}
        // Correct for 0 - 360 range limit for direction.
        if(direction > 360) {direction = (direction - 360);}
        if(direction < 0) {direction = (360 + direction);}
        if(front_detect == 1) {mower_on = 0;move_on = 0;} 
        if(rear_detect == 1) {mower_on = 0;safety = 1;}
        if(mower_on == 1) {digitalWrite (0, HIGH);}
             else {digitalWrite (0, LOW);}
        if(move_on == 1) {digitalWrite (1, HIGH);}
             else {digitalWrite (1, LOW);}
	return 0;
}

// Sets Steering Servo with the variable direction as the input.
// Needs to be upgraded to allow for more granular control.
int steering (int azimuth)
{
    int c;
    cout << "Steering Module " << azimuth << endl;
    if (azimuth >= 0 && azimuth <= 90){c = (90-azimuth)/10+6;}
    if (azimuth >=270 && azimuth <= 359) {c = (360-azimuth)/10+15;}
    if (azimuth > 90 && azimuth < 270) {c = 15;direction = 0;}
    return c;
}

int main (void)
{
  wiringPiSetup ();
  pinMode (0,OUTPUT); // Mower control
  pinMode (1,OUTPUT); // Move control - Currently On - Off may want to use a Variable Drive of some for trimming
  softPwmCreate (4,15,25);
  while (safety == 0)
  {
    controlupdate ();
    currentposition = steering (direction);
    softPwmWrite (4, currentposition);
    cout << "Direction : " << direction << endl;
    cout << "Servo Position : " << currentposition << endl;
    cout << "Mower Power : " << mower_on << endl;
    cout << "Move Power : " << move_on << endl;
    cout << "Safety : " << safety << endl;
    cout << "Front Obstruction Detect : " <<  front_detect << endl; 
    cout << "Left Obstruction Detect : " << left_detect << endl;
    cout << "Right Obstruction Detect : " << right_detect << endl;
    cout << "Rear Obstruction Detect : " << rear_detect << endl;
  }
  // Needs a reset plan if the safety goes off.
  return 0 ;
}
