/* Revised 110916.001
This uses the pigpio software PWM to adjust the servo plugged into GPIO23.
To compile use:
g++ -Wall -lpthread -o mowerpigpio mowerpigpio.cpp -lpigpio -lrt -std=c++14

*/

#include <iostream>
#include <pigpio.h>
#include <ctime>
#include <ratio>
#include <chrono> // For time controls.

using namespace std;
using namespace std::chrono;

// Initialize Control and set to nominal position.
    int mower_on = 0;  //GPIO17
    int move_on = 0;  //GPIO18
    int forward_reverse = 1; //GPIO27
    int direction = 0;// GPIO23 Uses azmuith relative to the orientation of the mower 0 is straight ahead, 90 is right, 270 is left Range is 0 - 360. 
    int safety = 0;
    int left_detect = 0;  //GPIO16
    int right_detect = 0;  //GPIO20
    int front_detect = 0; //GPIO12
    int rear_detect = 0;  //GPIO21
    int azimuth;
    int currentposition = 1500;
    int kbnumber;
    char kbchar;
    steady_clock::time_point time_boot;
    steady_clock::time_point time_current;
    steady_clock::time_point time_last_locate;
    steady_clock::time_point time_last_picture;
    steady_clock::time_point time_last_mowing;

/* Read the keybord so that it can be used as a remote control up down for move left right to turn.  "z" to stop program
 Assumes "a" = 97; "z" = 122; "w" = 119; "s" = 115.*/

int readkey (void)
{
	cin >> kbchar;
	kbnumber = kbchar;
	return (0);
}

// Reads Sensors and Updates Controls
int controlupdate (void)
{
        mower_on = 1;
        move_on = 1;
	forward_reverse = 1;
        // readkey (); // Make these 2 lines a note to switch to only detector control.
        // cout << "Results of Keyboard read " << kbchar << " = ASCII Number " << kbnumber << endl;
        cout << "Set Jumper for GPIO12, 16, 20 , or 21 " << endl;  
        //  *** cin >> kbchar;
        left_detect = gpioRead(16);
        right_detect = gpioRead(20);  
        rear_detect = gpioRead(21);  
        front_detect = gpioRead(12);
	cout << "Front Left Right Rear" << endl;
	cout << front_detect << "     " << left_detect << "    " << right_detect << "     " << rear_detect << endl;
        //  *** cin >> kbchar;
        if(left_detect == 1||kbnumber == 115) {mower_on = 0; direction = (direction + 10);}
        if(right_detect == 1||kbnumber == 97) {mower_on = 0; direction = (direction - 10);}
        if(left_detect == 0 && right_detect == 0) {direction = 0;}
        if(direction > 360) {direction = (direction - 360);}
        if(direction < 0) {direction = (360 + direction);}
        if(front_detect == 1) {mower_on = 0;move_on = 0;} 
        if(rear_detect == 1) {mower_on = 0;safety = 1;}
        if(mower_on == 1) {gpioWrite (17, 1);}
             else {gpioWrite (17, 0);}
        if(move_on == 1) {gpioWrite (18, 1);}
             else {gpioWrite (18, 0);}
	return 0;
}

// Sets Steering Servo with the variable direction as the input.
// Needs to be upgraded to allow for more granular control.

int steering (int azimuth)
{
    int c;
    cout << "Steering Module " << azimuth << endl;
    if (azimuth == 360) {c = 1500;}
    if (azimuth >= 0 && azimuth <= 90){c = 1500-azimuth*11;}
    if (azimuth >=270 && azimuth <= 359) {c = (360-azimuth)*11+1500;}
    if (azimuth > 90 && azimuth < 270) {c = 1500;direction = 0;}
    return c;
}

int main (void)
{
  time_boot = steady_clock::now();
  gpioInitialise ();
  gpioSetMode (17,PI_OUTPUT); // Mower control - GPIO17
  gpioSetMode (18,PI_OUTPUT); // Drive Motor Power control - GPIO18 ** Currently On - Off may want to use a Variable Drive of sorts for trimming
  gpioSetMode (27,PI_OUTPUT); // Drive Motor Forward/Reverse - GPIO27  
  gpioSetMode (12,PI_INPUT); // Front Detect Pin Number -  Normally Open switch to 3V on GPIO12 
  gpioSetMode (16,PI_INPUT); // Left Detect Pin Number - Normally Open switch to 3V on GPIO16
  gpioSetMode (20,PI_INPUT); // Right Detect Pin Number - Normally Open switch to 3V on GPIO20
  gpioSetMode (21,PI_INPUT); // Rear Detect Pin Number - Normally Open switch to 3V on GPIO21
  gpioSetPullUpDown (12,PI_PUD_DOWN);
  gpioSetPullUpDown (16,PI_PUD_DOWN);
  gpioSetPullUpDown (20,PI_PUD_DOWN);
  gpioSetPullUpDown (21,PI_PUD_DOWN);
  gpioPWM (23,128); //Activate and set steering servo plugged into pin 23 to 0
  gpioServo (23, 1500); 
  time_current = steady_clock::now();
  duration<double> time_span = duration_cast<duration<double>>(time_current - time_boot);
  while (time_span.count() < 60)
  {
    controlupdate ();
    currentposition = steering (direction);
    // system ("bash ./Picture.sh"); Saves a picture
    cout << "I have been running for " << time_span.count() << " seconds." << endl;
    gpioServo (23, currentposition);
    cout << "Direction : " << direction << endl;
    cout << "Servo Position : " << currentposition << endl;
    cout << "Mower Power : " << mower_on << endl;
    cout << "Move Power : " << move_on << endl;
    cout << "Safety : " << safety << endl;
    cout << "Front Obstruction Detect : " <<  front_detect << endl; 
    cout << "Left Obstruction Detect : " << left_detect << endl;
    cout << "Right Obstruction Detect : " << right_detect << endl;
    cout << "Rear Obstruction Detect : " << rear_detect << endl;
    gpioSleep(PI_TIME_RELATIVE, 1, 500000); // sleep for 1.5 seconds
    time_current = steady_clock::now();
    time_span = duration_cast<duration<double>>(time_current - time_boot);
  }
  // Needs a reset plan if the safety goes off.
  void gpioTerminate (void);
  return 0 ;
}
